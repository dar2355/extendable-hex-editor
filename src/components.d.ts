/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { IRegion, } from "./components/hex-editor/interfaces";
export namespace Components {
    interface FudgeHexEditor {
        /**
          * accepts and reads the given file, storing the result in the file variable
          * @param file
         */
        "acceptFile": (file: File) => Promise<void>;
        /**
          * weather or not to replace typical ASCII values with their ASCII value representation ( ex: 0x61 ==> ".a" )
          * @type {boolean}
          * @memberof HexEditor
         */
        "asciiInline": boolean;
        /**
          * the number of bytes to display per line
          * @type {number}
          * @memberof HexEditor
         */
        "bytesPerLine": number;
        /**
          * currently does nothing it WOULD force a line break every X bytes
          * @type {number}
          * @memberof HexEditor
          * @deprecated
         */
        "bytesUntilForcedLine": number;
        /**
          * the number of chunks between separators
          * @type {number}
          * @memberof HexEditor
         */
        "chunksPerGroup": number;
        /**
          * weather or not to display ASCII on the side
          * @type {boolean}
          * @memberof HexEditor
         */
        "displayAscii": boolean;
        /**
          * the mode of data entry: insert:     inserts data between bytes overwrite:     overwrites the currently selected byte readonly:     no edits are possible
          * @type {("insert" | "overwrite" | "readonly")}
          * @memberof HexEditor
         */
        "editType": "insert" | "overwrite" | "readonly";
        /**
          * fetches a Uint8Array of a given length at the given location
          * @param location where to fetch the data from
          * @param length how many bytes to load
          * @memberof HexEditor
         */
        "getChunk": (location: number, length: number) => Promise<{
            out: Uint8Array;
            meta: {
                added: [number, number][];
            };
        }>;
        /**
          * returns the file's metadata
          * @memberof HexEditor
         */
        "getFileMetadata": () => Promise<File>;
        /**
          * the number of lines to display at once
          * @type {number}
          * @memberof HexEditor
         */
        "maxLines": number;
        /**
          * the mode of operation: region:     used to highlight different regions. Hovering over     a region displays a tooltip edit:     regions are displayed in the background, allowing     the user to edit directly noregion:     regions are not displayed at all
          * @type {("region" | "edit" | "noregion")}
          * @memberof HexEditor
         */
        "mode": "region" | "edit" | "noregion";
        /**
          * the number of regions to traverse
          * @type {number}
          * @memberof HexEditor
         */
        "regionDepth": number;
        /**
          * the region data. Data will be displayed in the tooltip if mode is set to "region"
          * @type {IRegion[]}
          * @memberof HexEditor
         */
        "regions": IRegion[];
        /**
          * returns the edited file
          * @returns
          * @memberof HexEditor
         */
        "saveFile": () => Promise<void | Uint8Array>;
        "searchByteCount": 1 | 2 | 4 | 8;
        "searchEndian": "big" | "little";
        "searchInput": string;
        /**
          * the type of search to be executed
          * @type {('ascii' | 'byte' | 'integer' | 'float')}
          * @memberof HexEditor
         */
        "searchType": "ascii" | "byte" | "integer" | "float";
        /**
          * sets the new cursor position
          * @param newCursorPosition
          * @memberof HexEditor
         */
        "setCursorPosition": (newCursorPosition: number) => Promise<void>;
        /**
          * sets the line number
          * @param newLineNumber
          * @memberof HexEditor
         */
        "setLineNumber": (newLineNumber: number) => Promise<void>;
        /**
          * sets the new selection bounds.
          * @param newSelection
          * @memberof HexEditor
         */
        "setSelection": (newSelection: {
            start?: number;
            end?: number;
        }) => Promise<void>;
    }
    interface FudgeHexTooltip {
        "active": boolean;
        "data": {
            [key: string]: string;
        } | string;
        "simpleText": string;
    }
}
declare global {
    interface HTMLFudgeHexEditorElement extends Components.FudgeHexEditor, HTMLStencilElement {
    }
    var HTMLFudgeHexEditorElement: {
        prototype: HTMLFudgeHexEditorElement;
        new (): HTMLFudgeHexEditorElement;
    };
    interface HTMLFudgeHexTooltipElement extends Components.FudgeHexTooltip, HTMLStencilElement {
    }
    var HTMLFudgeHexTooltipElement: {
        prototype: HTMLFudgeHexTooltipElement;
        new (): HTMLFudgeHexTooltipElement;
    };
    interface HTMLElementTagNameMap {
        "fudge-hex-editor": HTMLFudgeHexEditorElement;
        "fudge-hex-tooltip": HTMLFudgeHexTooltipElement;
    }
}
declare namespace LocalJSX {
    interface FudgeHexEditor {
        /**
          * weather or not to replace typical ASCII values with their ASCII value representation ( ex: 0x61 ==> ".a" )
          * @type {boolean}
          * @memberof HexEditor
         */
        "asciiInline"?: boolean;
        /**
          * the number of bytes to display per line
          * @type {number}
          * @memberof HexEditor
         */
        "bytesPerLine"?: number;
        /**
          * currently does nothing it WOULD force a line break every X bytes
          * @type {number}
          * @memberof HexEditor
          * @deprecated
         */
        "bytesUntilForcedLine"?: number;
        /**
          * the number of chunks between separators
          * @type {number}
          * @memberof HexEditor
         */
        "chunksPerGroup"?: number;
        /**
          * weather or not to display ASCII on the side
          * @type {boolean}
          * @memberof HexEditor
         */
        "displayAscii"?: boolean;
        /**
          * the mode of data entry: insert:     inserts data between bytes overwrite:     overwrites the currently selected byte readonly:     no edits are possible
          * @type {("insert" | "overwrite" | "readonly")}
          * @memberof HexEditor
         */
        "editType"?: "insert" | "overwrite" | "readonly";
        /**
          * the number of lines to display at once
          * @type {number}
          * @memberof HexEditor
         */
        "maxLines"?: number;
        /**
          * the mode of operation: region:     used to highlight different regions. Hovering over     a region displays a tooltip edit:     regions are displayed in the background, allowing     the user to edit directly noregion:     regions are not displayed at all
          * @type {("region" | "edit" | "noregion")}
          * @memberof HexEditor
         */
        "mode"?: "region" | "edit" | "noregion";
        /**
          * Emitted on the change of the cursor's position
          * @type {EventEmitter}
          * @memberof HexEditor
         */
        "onHexCursorChanged"?: (event: CustomEvent<any>) => void;
        /**
          * fired when the file's data changes
          * @type {EventEmitter}
          * @memberof HexEditor
         */
        "onHexDataChanged"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the lineNumber changes
          * @type {EventEmitter}
          * @memberof HexEditor
         */
        "onHexLineChanged"?: (event: CustomEvent<any>) => void;
        /**
          * fired when the component loads
         */
        "onHexLoaded"?: (event: CustomEvent<any>) => void;
        /**
          * Emitted when the selection changes
          * @type {EventEmitter}
          * @memberof HexEditor
         */
        "onHexSelectionChanged"?: (event: CustomEvent<any>) => void;
        /**
          * the number of regions to traverse
          * @type {number}
          * @memberof HexEditor
         */
        "regionDepth"?: number;
        /**
          * the region data. Data will be displayed in the tooltip if mode is set to "region"
          * @type {IRegion[]}
          * @memberof HexEditor
         */
        "regions"?: IRegion[];
        "searchByteCount"?: 1 | 2 | 4 | 8;
        "searchEndian"?: "big" | "little";
        "searchInput"?: string;
        /**
          * the type of search to be executed
          * @type {('ascii' | 'byte' | 'integer' | 'float')}
          * @memberof HexEditor
         */
        "searchType"?: "ascii" | "byte" | "integer" | "float";
    }
    interface FudgeHexTooltip {
        "active"?: boolean;
        "data"?: {
            [key: string]: string;
        } | string;
        "simpleText"?: string;
    }
    interface IntrinsicElements {
        "fudge-hex-editor": FudgeHexEditor;
        "fudge-hex-tooltip": FudgeHexTooltip;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "fudge-hex-editor": LocalJSX.FudgeHexEditor & JSXBase.HTMLAttributes<HTMLFudgeHexEditorElement>;
            "fudge-hex-tooltip": LocalJSX.FudgeHexTooltip & JSXBase.HTMLAttributes<HTMLFudgeHexTooltipElement>;
        }
    }
}
